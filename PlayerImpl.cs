//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18033
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	[Serializable]
	public class PlayerImpl : Player	{

		private int id;
		private string name;
		private int currentPlayerLevel;
		private int currentQuestionLevel;
		private int maxQuestionLevel;
		private int minQuestionLevel;
		private int maxPlayerLevel;
		private int minPlayerLevel;
		private int score;
		private bool playerHasFinished;

		private Dictionary<int,Dictionary<int, Level>> playerLevelsHash;
		private Dictionary<int,PlayerLevelFlags> playerLevelsFlagsHash;

		public PlayerImpl (string name, List<Question> questions, List<PlayerLevelFlags>  playerLevels) {
			this.id = name.GetHashCode();
			this.name = name;
			maxPlayerLevel = 0;
			minPlayerLevel = 99;
			maxQuestionLevel = 0;
			minQuestionLevel = 99;
			playerHasFinished = false;

			playerLevelsHash = new Dictionary<int,Dictionary<int, Level>>  ();
			playerLevelsFlagsHash = new Dictionary<int,PlayerLevelFlags> ();

			foreach (PlayerLevelFlags myLevel in playerLevels) {
				Dictionary<int, Level> myPlayerHash = populatePlayerLevels(questions);
				playerLevelsHash.Add(myLevel.id, myPlayerHash);
				playerLevelsFlagsHash.Add(myLevel.id, myLevel);
				if (myLevel.id>maxPlayerLevel) maxPlayerLevel=myLevel.id;
				if (myLevel.id<minPlayerLevel) minPlayerLevel=myLevel.id;
			}

			this.currentPlayerLevel = minPlayerLevel;
			this.currentQuestionLevel = minQuestionLevel;
		}

		public bool isFinished() {
			return playerHasFinished;
		}

		public void setToFinished() {
			playerHasFinished = true;
		}

		public bool updatePlayerLevel() {
			bool levelUpdated = false;
			if (currentQuestionLevel < maxQuestionLevel) {
				currentQuestionLevel++;
				levelUpdated = true;
			} else {
				if (currentPlayerLevel<maxPlayerLevel) {
					currentQuestionLevel = minQuestionLevel;
					currentPlayerLevel++;
					levelUpdated=true;
				}
			}

			return levelUpdated;
		}

		public void updatePlayerLevel(int currentPlayerLevel, int currentQuestionLevel) {
			this.currentPlayerLevel = currentPlayerLevel;
			this.currentQuestionLevel = currentQuestionLevel;
		}

		private Dictionary<int, Level> populatePlayerLevels(List<Question> questions) {
			int currentLevel = 0;
			Level myLevel;
			List<Question> subset = new List<Question> ();
			Dictionary<int, Level> inHash = new Dictionary<int, Level> ();
			int questionCount = 0;

			foreach (Question myQuestion in questions) // Loop through List with foreach
			{
				/// I want to loop through and strip out the questions for the current level into a smaller list
				/// I need to maintain a count of the questions
				/// then I want to create a new level and add this subset of questions to that level ... 
				/// LevelImpl (int level, List<Question> unansweredQuestions, int numberOfQuestions)
				/// then I want to create a hashtable with values "number for the currentLevel", "pointer to the newlyCreatedLevel"
				
				/// then move onto a new level when the level number changes
				int tempLevel = myQuestion.getLevel();
				if (tempLevel>currentLevel) {
					// write the current level to the hashmap, unless this is first time through
					if (subset.Count>0) {
						myLevel = new LevelImpl(currentLevel, subset, questionCount);
						inHash.Add(currentLevel, myLevel);
						subset = new List<Question>();
						if (currentLevel>maxQuestionLevel) maxQuestionLevel=currentLevel;
						if (currentLevel<minQuestionLevel) minQuestionLevel=currentLevel;
					}

					currentLevel=tempLevel;
					subset.Add(myQuestion);
					questionCount = 1;

				} else {
					subset.Add(myQuestion);
					questionCount++;
				}
			}
			//the following line saves the final group of questions
			if (subset.Count>0) {
				myLevel = new LevelImpl(currentLevel, subset, questionCount);
				inHash.Add(currentLevel, myLevel);
				if (currentLevel>maxQuestionLevel) maxQuestionLevel=currentLevel;
				if (currentLevel<minQuestionLevel) minQuestionLevel=currentLevel;
			}
			return inHash;
		}

		public int getId() {
			return id;
		}

		public int getcurrentPlayerLevel() {
			return currentPlayerLevel;
		}

		public PlayerLevelFlags getPlayerLevelFlags() {
			return playerLevelsFlagsHash [currentPlayerLevel];
		}

		public Level getcurrentQuestionLevel() {
			Level myLevel = null;

			Dictionary<int, Level> myHash = playerLevelsHash [currentPlayerLevel];
			myLevel = myHash[currentQuestionLevel];

			return myLevel;
		}

		public string getName() {
			return name;
		}

		public void updateScore(int quizId, int score) {
			this.score = score;
		}

		public int getScore(int quizId) {
			return this.score;
		}

		/*
		// this is just a test function .. remove when tested
		public string getplayerLevelsHash() {
			string myStr = "";
			myStr = "maxPL=" + maxPlayerLevel + " minPL=" + minPlayerLevel + "maxQL=" + maxQuestionLevel + " minQL=" + minQuestionLevel;
			myStr = myStr + " playerLevelHash entries = " + playerLevelsHash.Count + " ";
			int j = minPlayerLevel;
			
			Hashtable myTempHash = (Hashtable)playerLevelsHash [1];
			Level myTempLevel = (Level)myTempHash [1];
			Question myQ1 = myTempLevel.getNextUnansweredQuestion ();
			//myStr = myStr + "entry " + j + "." + i + "=" + myQ1.getStartHours ().ToString () + ":" + myQ1.getsStartMinutes ().ToString ();
			myStr = myStr + "entry 1.1=" + myQ1.getStartHours ().ToString () + ":" + myQ1.getsStartMinutes ().ToString ();
			myStr = myStr + "->" + myQ1.getEndHours ().ToString () + ":" + myQ1.getEndMinutes ().ToString ();

			myTempHash = (Hashtable)playerLevelsHash [4];
			myTempLevel = (Level)myTempHash [9];
			myQ1 = myTempLevel.getNextUnansweredQuestion ();
			//myStr = myStr + "entry " + j + "." + i + "=" + myQ1.getStartHours ().ToString () + ":" + myQ1.getsStartMinutes ().ToString ();
			myStr = myStr + "entry 4.9=" + myQ1.getStartHours ().ToString () + ":" + myQ1.getsStartMinutes ().ToString ();
			myStr = myStr + "->" + myQ1.getEndHours ().ToString () + ":" + myQ1.getEndMinutes ().ToString ();

			List<float> answer = new List<float>();
			answer.Add(1.0f);
			answer.Add(30.0f);
			bool validAnswer=true;
			
			while (j<=maxPlayerLevel) {
				myStr = myStr + "\np"+j+":";
				Hashtable myTempHash = (Hashtable)playerLevelsHash [j];
				//myStr = myStr + "p#Size=" + playerLevelsHash.Count.ToString()+" ";
				int i = minQuestionLevel;
				
				Level myTempLevel = (Level)myTempHash [1];
				myStr = myStr + "levelId" + myTempLevel.getLevel().ToString()+" ";
				myStr = myStr + "UnAnswquestionNo=" + myTempLevel.getUnansweredQuestions().Count.ToString();

				i=9;
				myTempLevel = (Level)myTempHash [i];
				myStr = myStr + "levelId" + myTempLevel.getLevel().ToString()+" ";
				myStr = myStr + "UnAnswquestionNo=" + myTempLevel.getUnansweredQuestions().Count.ToString();
				//Level myTempLevel;
				
				while (i<=maxQuestionLevel) {
					
					myStr = myStr + "q"+i+"-";
					
					Level myTempLevel = (Level)myTempHash [i];
					myStr = myStr + "LvLId=" + myTempLevel.getLevel().ToString()+",";
					myStr = myStr + myTempLevel.getUnansweredQuestions().Count.ToString()+" ";
					List<Question> unansweredQuestions = myTempLevel.getUnansweredQuestions();
					//myStr = myStr + " StartHr="+unansweredQuestions[0].getStartHours().ToString() + "." + unansweredQuestions[0].getsStartMinutes().ToString() + ";";
					Question myQ1 = myTempLevel.getNextUnansweredQuestion ();
					while (myQ1!=null) {
						myStr = myStr + " t="+myQ1.getStartHours().ToString() + "." + myQ1.getsStartMinutes().ToString() + ";";
						myTempLevel.questionCompleted(myQ1, answer, validAnswer);
						myQ1= myTempLevel.getNextUnansweredQuestion ();
					}
					//myQ1 = myTempLevel.getNextUnansweredQuestion ();
					//myStr = myStr + " t1="+myQ1.getStartHours().ToString() + "." + myQ1.getsStartMinutes().ToString() + ";";
					
					Question myQ1 = myTempLevel.getNextUnansweredQuestion ();
					//myStr = myStr + "questionNo=" + myTempLevel.getnumberOfQuestions().ToString();

					while (myQ1!=null) {
						myStr = myStr + "entry " + j + "." + i + "=" + myQ1.getStartHours ().ToString () + ":" + myQ1.getsStartMinutes ().ToString ();
						myStr = myStr + "->" + myQ1.getEndHours ().ToString () + ":" + myQ1.getEndMinutes ().ToString ();
						myTempLevel.questionCompleted (myQ1, null, true);
						myQ1 = myTempLevel.getNextUnansweredQuestion ();
					}
					i++;
				}
				j++;
			}
			return myStr;		
		}
		*/
	}
}

