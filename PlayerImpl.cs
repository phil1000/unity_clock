//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18033
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	[Serializable]
	public class PlayerImpl : Player	{

		private int id;
		private string name;
		private int currentPlayerLevel;
		private int currentQuestionLevel;
		private int maxQuestionLevel;
		private int minQuestionLevel;
		private int maxPlayerLevel;
		private int minPlayerLevel;
		//private int score;
		private bool playerHasFinished;

		private Dictionary<int,Dictionary<int, Level>> playerLevelsHash;
		private Dictionary<int,PlayerLevelFlags> playerLevelsFlagsHash;

		public PlayerImpl (string name, List<Question> questions, List<PlayerLevelFlags>  playerLevels) {
			this.id = name.GetHashCode();
			this.name = name;
			maxPlayerLevel = 0;
			minPlayerLevel = 99;
			maxQuestionLevel = 0;
			minQuestionLevel = 99;
			playerHasFinished = false;

			playerLevelsHash = new Dictionary<int,Dictionary<int, Level>>  ();
			playerLevelsFlagsHash = new Dictionary<int,PlayerLevelFlags> ();

			foreach (PlayerLevelFlags myLevel in playerLevels) {
				Dictionary<int, Level> myPlayerHash = populatePlayerLevels(questions);
				playerLevelsHash.Add(myLevel.id, myPlayerHash);
				playerLevelsFlagsHash.Add(myLevel.id, myLevel);
				if (myLevel.id>maxPlayerLevel) maxPlayerLevel=myLevel.id;
				if (myLevel.id<minPlayerLevel) minPlayerLevel=myLevel.id;
			}

			this.currentPlayerLevel = minPlayerLevel;
			this.currentQuestionLevel = minQuestionLevel;
		}

		public bool isFinished() {
			return playerHasFinished;
		}

		public void setToFinished() {
			playerHasFinished = true;
		}

		public bool updatePlayerLevel() {
			bool levelUpdated = false;
			if (currentQuestionLevel < maxQuestionLevel) {
				currentQuestionLevel++;
				levelUpdated = true;
			} else {
				if (currentPlayerLevel<maxPlayerLevel) {
					currentQuestionLevel = minQuestionLevel;
					currentPlayerLevel++;
					levelUpdated=true;
				}
			}

			return levelUpdated;
		}

		public void updatePlayerLevel(int currentPlayerLevel, int currentQuestionLevel) {
			this.currentPlayerLevel = currentPlayerLevel;
			this.currentQuestionLevel = currentQuestionLevel;
		}

		private Dictionary<int, Level> populatePlayerLevels(List<Question> questions) {
			int currentLevel = 0;
			Level myLevel;
			List<Question> subset = new List<Question> ();
			Dictionary<int, Level> inHash = new Dictionary<int, Level> ();
			int questionCount = 0;

			foreach (Question myQuestion in questions) // Loop through List with foreach
			{
				/// I want to loop through and strip out the questions for the current level into a smaller list
				/// I need to maintain a count of the questions
				/// then I want to create a new level and add this subset of questions to that level ... 
				/// LevelImpl (int level, List<Question> unansweredQuestions, int numberOfQuestions)
				/// then I want to create a hashtable with values "number for the currentLevel", "pointer to the newlyCreatedLevel"
				
				/// then move onto a new level when the level number changes
				int tempLevel = myQuestion.getLevel();
				if (tempLevel>currentLevel) {
					// write the current level to the hashmap, unless this is first time through
					if (subset.Count>0) {
						myLevel = new LevelImpl(currentLevel, subset, questionCount);
						inHash.Add(currentLevel, myLevel);
						subset = new List<Question>();
						if (currentLevel>maxQuestionLevel) maxQuestionLevel=currentLevel;
						if (currentLevel<minQuestionLevel) minQuestionLevel=currentLevel;
					}

					currentLevel=tempLevel;
					subset.Add(myQuestion);
					questionCount = 1;

				} else {
					subset.Add(myQuestion);
					questionCount++;
				}
			}
			//the following line saves the final group of questions
			if (subset.Count>0) {
				myLevel = new LevelImpl(currentLevel, subset, questionCount);
				inHash.Add(currentLevel, myLevel);
				if (currentLevel>maxQuestionLevel) maxQuestionLevel=currentLevel;
				if (currentLevel<minQuestionLevel) minQuestionLevel=currentLevel;
			}
			return inHash;
		}

		public int getId() {
			return id;
		}

		public int getcurrentPlayerLevel() {
			return currentPlayerLevel;
		}

		public PlayerLevelFlags getPlayerLevelFlags() {
			return playerLevelsFlagsHash [currentPlayerLevel];
		}

		public Level getcurrentQuestionLevel() {
			Level myLevel = null;

			Dictionary<int, Level> myHash = playerLevelsHash [currentPlayerLevel];
			myLevel = myHash[currentQuestionLevel];

			return myLevel;
		}

		public string getName() {
			return name;
		}

	}
}

